"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8148],{4510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=t(5893),a=t(1151);const s={id:"documents",title:"Working with documents",tags:["Document"]},i=void 0,r={id:"gettingstarted/documents",title:"Working with documents",description:"Working with documents",source:"@site/docs/gettingstarted/documents.md",sourceDirName:"gettingstarted",slug:"/gettingstarted/documents",permalink:"/mongo4cats/docs/gettingstarted/documents",draft:!1,unlisted:!1,tags:[{label:"Document",permalink:"/mongo4cats/docs/tags/document"}],version:"current",frontMatter:{id:"documents",title:"Working with documents",tags:["Document"]},sidebar:"docsSidebar",previous:{title:"Getting a collection",permalink:"/mongo4cats/docs/gettingstarted/collection"},next:{title:"Operations",permalink:"/mongo4cats/docs/operations"}},d={},c=[{value:"Working with documents",id:"working-with-documents",level:2},{value:"Creating new documents",id:"creating-new-documents",level:3},{value:"Updating documents",id:"updating-documents",level:3},{value:"Retrieving values",id:"retrieving-values",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"working-with-documents",children:"Working with documents"}),"\n",(0,o.jsx)(n.p,{children:"MongoDB stores data records as BSON documents. BSON is a binary representation of JSON objects, though it contains more data types than JSON."}),"\n",(0,o.jsx)(n.p,{children:"Documents are composed of key-and-value pairs, where keys are represented as regular strings and values can be any of the BSON data types, including other documents, arrays, and arrays of documents."}),"\n",(0,o.jsx)(n.h3,{id:"creating-new-documents",children:"Creating new documents"}),"\n",(0,o.jsxs)(n.p,{children:["A document can be created by using one of the available constructor methods in ",(0,o.jsx)(n.code,{children:"Document"})," companion object:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import mongo4cats.bson.{BsonValue, Document, ObjectId}\nimport java.time.Instant\n\nval doc: Document = Document(\n  "_id"            -> BsonValue.objectId(ObjectId.gen),\n  "null"           -> BsonValue.Null,\n  "string"         -> BsonValue.string("str"),\n  "int"            -> BsonValue.int(1),\n  "boolean"        -> BsonValue.boolean(true),\n  "double"         -> BsonValue.double(2.0),\n  "int"            -> BsonValue.int(1),\n  "long"           -> BsonValue.long(1660999000L),\n  "dateTime"       -> BsonValue.instant(Instant.now),\n  "array"          -> BsonValue.array(BsonValue.string("item1"), BsonValue.string("item2"), BsonValue.string("item3")),\n  "nestedDocument" -> BsonValue.document(Document("field" -> BsonValue.string("nested")))\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["To avoid having a need for wrapping every value in ",(0,o.jsx)(n.code,{children:"BsonValue"}),", additional syntax can be imported from ",(0,o.jsx)(n.code,{children:"mongo4cats.bson.syntax"})," package, which will enable automatic conversion of key-value pairs into bson with ",(0,o.jsx)(n.code,{children:":="})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import mongo4cats.bson.syntax._\n\nval doc: Document = Document(\n  "_id"            := ObjectId.gen,\n  "null"           := BsonValue.Null,\n  "string"         := "str",\n  "int"            := 1,\n  "boolean"        := true,\n  "double"         := 2.0,\n  "int"            := 1,\n  "long"           := 1660999000L,\n  "dateTime"       := Instant.now,\n  "array"          := List("item1", "item2", "item3"),\n  "nestedDocument" := Document("field" := "nested")\n)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"updating-documents",children:"Updating documents"}),"\n",(0,o.jsx)(n.p,{children:"Documents are immutable in nature, therefore adding a new value to a document will result in creation of a new document. There are several methods available for updating documents:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val updatedDoc1 = doc.add("newField" -> BsonValue.string("string"))\nval updatedDoc2 = doc.add("newField" -> "string")\nval updatedDoc3 = doc += ("anotherNewField" -> BsonValue.instant(ts))\nval updatedDoc4 = doc += ("anotherNewField" := 1)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"retrieving-values",children:"Retrieving values"}),"\n",(0,o.jsxs)(n.p,{children:["Internally, all field values are stored as ",(0,o.jsx)(n.code,{children:"BsonValue"}),". To retrieve a value by key, several variations of get methods exist:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val stringField1: Option[BsonValue] = doc.get("string")\nval stringField2: Option[String]    = doc.getString("string")\nval stringField3: Option[String]    = doc.getAs[String]("string")\n\nval arrayField1: Option[BsonValue]       = doc.get("array")\nval arrayField2: Option[List[BsonValue]] = doc.getList("array")\nval arrayField3: Option[List[String]]    = doc.getAs[List[String]]("array")\n\nval nestedField1: Option[BsonValue] = doc.getNested("nestedDocument.field")\nval nestedField2: Option[String]    = doc.getNestedAs[String]("nestedDocument.field")\n'})}),"\n",(0,o.jsx)(n.p,{children:"If a requested value is not present in the document, an empty option will be returned."})]})}function u(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>i});var o=t(7294);const a={},s=o.createContext(a);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);